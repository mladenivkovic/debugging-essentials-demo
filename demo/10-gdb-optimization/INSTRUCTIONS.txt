10 GDB optimization
===========================

1   Look through the source code of the program.
    The base program is the same as in exampe 08-gdb-segfault, except that the
    loop has been moved into a function.

2   Don't forget to compile with the debug flags! Point them out on the compile
    command. To compile the code, run `make`, or the full compilation command
    manually, e.g.

        $ make

    or

        $ gcc main.c -O3 -o ex -g -lm
    
    note that for this example, we want maximally aggressive optimisation, so
    we're using the -O3 flag.

3   run the program:

        $ ./ex

    It should crash with a Segfault.


4   run the program with gdb:

        $ gdb ./ex
        (gdb) run

    It should halt at the Segfault, writing something like:

        Program received signal SIGSEGV, Segmentation fault.
        0x00005555555551d2 in assign_array_values (arr=<optimized out>, elements=elements@entry=10000000) at main.c:18
        18	   arr[i] = i;

    Here wee see that some values may be optimised out, such ass the `arr` variable.
    We can't see its value:

        (gdb) p arr
        $1 = <optimized out>
        (gdb) p *arr
        value has been optimized out


5   We have two options to deal with that

5.1 Disable optimisation of the entire program: Compile with -O0 flag instead
    of the -O3 flag

5.2 Distable optimisation for a single function. If you're using gcc, you can
    uncomment the following lines in main.c:

        /* #pragma GCC push_options */                               // <- this one
        /* #pragma GCC optimize ("O0") */                            // <- this one
        void assign_array_values(int *arr, const int elements){

        // contents....
        /* #pragma GCC pop_options */                                // <- this one

    Examples for other compilers are given as a comment at the bottom of main.c

    Re-compile and re-run your program with gdb, and `arr` should now be accessible!


